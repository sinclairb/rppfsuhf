Reconstructing Plaintext Passwords From Simple Unsalted Hash Functions
Background 
Cryptography, or the use of codes and ciphers, is an integral part to modern life. Whether one realizes it or not, most people rely on cryptography on a daily basis. All digital information is, to some extent, based in cryptography. On the most fundamental level, digital information is encoded as zeros and ones, called binary “bits”. These bits are interpreted by computers and translated to human-readable text, called plaintext. Of course, other kinds of ciphers and encryption are used in computing as well. Any data that can be potentially sensitive, such as communications, login information, web activity, etc., can and should be encrypted. The encryption of digital data assures three things, viz:
Confidentiality: Confidentiality  refers to the limitation of access to information. Confidentiality prevents the access of sensitive information by unauthorized persons. 
Integrity: Integrity refers to the verification that accessed information is trustworthy. Integrity verifies that received data have not been tampered with, and have been sent by trusted sources.
Availability: Availability refers to ensuring that information can be accessed by those who need access to it. Availability also takes into account the ease of accessing information.
Because ciphers are so integral to digital security, creating, using, and maintaining secure encryption processes is of paramount importance in today’s increasingly-digital world.
Perhaps one of the most relied upon methods of securing digital information is through the use of passwords. Passwords serve as the first—and in many cases, the only—line of defence against malicious actors. With modern technology, some of our most important and sensitive information is stored digitally—be it in the form of emails, banking and shopping information, work-related documents, or simply personal or private data. As such, there are many individuals and groups determined to accrue as much of this sensitive information as possible. And, although it may be bothersome, it is the responsibility of each individual to make sure that their own confidential information is kept as such via the employment of secure passwords.
With the many cyber attacks focused on gathering user account information—notably the 2017 Yahoo and 2016 Adult Friend Finder breaches—perpetrators seek to gather as many usernames and passwords of site users as possible. To maximize the information they gain access to, attackers typically focus on a large sample of victims without spending more time than needed pursuing information that is harder to obtain. This means that if potential victims take it upon themselves to maximize their own security—in this case through the use of secure passwords—potential damage inflicted on them may be diminished or entirely avoided.
Most generally, passwords for online accounts are stored on web servers. Web servers store much—and sometimes all­—of the information about a website, including the text and images that comprise the website, as well as any behind-the-scenes scripts and databases needed for the website to function. As with all things digital, web servers are susceptible to breaches, and because servers can hold a plethora of sensitive and valuable information, they are frequently targeted for attack. Considering this, the way passwords are stored on servers is incredibly integral to assuring users' security.
In most cases, passwords are stored on servers using one of three methods: plaintext storage, encryption, or hashing. Plaintext storage, as alluded to previously, consists of merely storing user passwords on a list without changing the password in any way. When a user inputs their password, the site simply compares their input password to the stored password. Of course, this means that if the server is unlawfully accessed, all stored passwords can be obtained with no extra effort. The encryption of passwords, in this context, refers to using a cryptographic key to obfuscate a user’s password. However, most types of encryption are easily reversed, and, due to the nature of how sites work and are managed, the key used to encrypt passwords is usually stored on the same machine as the list of encrypted passwords. This means, again, stored passwords can be stolen with little additional effort. 
Hashing functions much like encryption in that it obfuscates passwords, yet hashing can be vastly more secure. Rather than merely using a key to encrypt passwords, hashing employs a mathematical algorithm designed to be—theoretically—irreversible, called a hash function. In mathematics, a function is defined as the relation between a set of inputs and its set of outputs, provided that each input is related to exactly one output. Where a hash function differs from this, however, is that each output can have—theoretically—an infinite number of inputs. For example, in the formula x2=y, x can always be found by finding the square root of y. In a cryptographically secure hash function, any attempt to find x would result in an infinite number of possible values.
The simplest example of a hash function can be expressed by nearly any equation using the modulus—alternatively referred to as the modulo—operator, usually written as “%”. In computing, the modulus operator refers to the outputting of the remainder of Euclidean integer division. Euclidean division is the process of the division of two integers, such that they result in both a quotient and a modulus. The most recognized form of Euclidean division is perhaps long division. When, for example, 47 is divided by 31, 31 can go into 47 evenly once, with a remainder, or modulus, of 16. The modulus operator is widely used in hash functions, as an infinite number of inputs can all output the same modulus. For example, a simple hash function can be expressed as x%p=h, where x is the input, p is a prime number chosen by the creators of the function, and h is outputted hashed value. If a user inputs x as 47 while p=31, h will be outputted as 16, i.e. 47%31=16. In other words, the user’s password would have been evaluated to 47 by an earlier part of code, the creator of the hash function chose 31 as the prime, and 16 is the hashed password actually stored on the web server. However, as previously mentioned, every output has an infinite number of possible inputs that evaluate to it. In this example, 78%31=16, 109%31=16, 140%31=16, ad infinitum.
Although hashing passwords is the most secure way to obfuscate stored passwords, hashing, in practice, can still be exploited in such a way as to output plaintext. Due to the cyclical nature of modulus operator, the inverse operation of modulus can be expressed as N*p+h=x, where N is every natural number. By utilizing this transformed formula, the evaluated password, x, can be determined from a list of all possible values of x. 
Although publically used hash functions are admittedly more complex than the aforementioned simple hash function, any publically used hash function, given enough time, can be reverse engineered. Imagine, for example, a numerical password, 47, is input into a website and is hashed to the value of  94. Almost immediately, one might realize that the algorithm used to encrypt the password is merely p*2, and this conclusion can be further tested by utilizing the algorithm additional times. Obviously, hashing algorithms are more complex than merely multiplying a number by two; yet as machine learning and more powerful computers become more prevalent, the autonomous reverse engineering of hash functions falls easily within reach. As such, it can be assumed that any hash function, regardless of complexity or obfuscation, can be reverse engineered into a transformed formula, and thus be mathematically reversed to enable the reassembly of plaintext.
Experiment
	Considering the inevitability of hash functions being reverse engineered, the major factor limiting the reassembly of plaintext is the complexity of both passwords and the hash function itself. This experiment will explore the fragility and durability of the use of hash functions to obfuscate stored passwords, and how the complexity of user-chosen passwords can influence the difficulty or ease with which plaintext is reassembled from hashed passwords. 
Experiment Procedure
	For the purposes of testing, imagine a website has the following password complexity requirements when creating an account:
"A password must be four letters long. Passwords are not case-sensitive."
These requirements indicate that all passwords are exactly four characters long, upper and lowercase letters will resolve to the same hash, and that all passwords will contain alphabetical characters only. These password regulations will directly influence how the hashes will be cracked.
Hashing
A java program was created specifically for this project to hash passwords in order to simulate the above fictional website. The program seeks user input of a four-letter password, converts all letters to lowercase, and discards any numerals or special characters. The program then converts each letter into an integer, as dictated by its ASCII value, and adds those values together, to obtain the total value of the password. This total is then hashed using the aforementioned simple hash function: total%31=h. To demonstrate, the password “test” consists of the ASCII values 116, 101, 115, 116; for t, e, s, and t, respectively. When added, these values equal the total of 448, which, when hashed using 448%31=h, results in the hashed value of h=14.
Dehashing
Obtaining Possible Totals
A second program was created to simulate a scenario where a hashed password was recovered from the above fictional web server. As discussed above, it can be assumed that the algorithm used to hash the passwords is known. The program first determines the possible ASCII totals of the unknown password by utilizing the formula  N*31+h=x, where N represents all natural numbers, x represents the respective possible total, and h represents the hashed password. However, in this testing environment, because it is known that a password is four lowercase letters, the value of x must always inclusively be between 388(aaaa) or 488(zzzz). Any possible totals outside of this range need not be considered during testing. In our example, the formula N*31+14=x is used. Knowing that 388x488; 13, 14, and 15 are the only acceptable values for N; which output x={417, 448, 479}. These numbers are the possible totals our example password could have parsed into. 
Obtaining Possible English Passwords
	Next, the program searches a dictionary, which contains conjugations of words as well, and creates a list of words that meet the aforementioned password complexity. The program then determines the ASCII totals of each word on the newly fabricated list. The words that share ASCII totals with the previously calculated possible totals are thereby possible user-inputted passwords. With the example password “test”, where x={417, 448, 479} and  h=14, there are 95 english words that qualify as possible passwords, such as: 
“uses” (117+115+101+115=448=x); “zero” (122+101+114+111=448=x); 
 “test” (116+101+115+116=448=x); and “bird” (98+105+114+100=417=x).
Obtaining Remaining Possible Letter Permutations
	In its final dehashing step, the program calculates the remaining possible letter permutations that add to each of the possible totals. The program cycles through each letter permutation that adheres to the password complexity requirements, viz: {aaaa, aaab, aaac,... aaaz, aaba, aabb,aabc,... abaa,... ahdgf, ahdgg, ... zzzz}
Each permutation is then cross-referenced with the previously created list of dictionary words to eliminate repetition, and each unique permutation is subsequently added to the list of possible passwords. Although these collective operations may seem complex and time-consuming, which would potentially limit the feasibility of utilizing this program for its intended use, with modern computers, these steps are completed within fractions of a second, thus showcasing, in a simplified manner, how hash functions can be reversed in such a way as to output a list of possible plaintext passwords.
Measurements and Results
	In this program’s current state and criteria, or if the program were to be modified to meet different password criteria, there is a 100% chance of discovering the original password within the list of outputted possible plaintext passwords. Identifying the original passwords as one of the possible passwords is not, however, the paramount limitation of such a program. The main limitation of the feasibility of any complex decryption program is instead the amount of time used to identify the original plaintext as such, after calculating all possible plaintext passwords.
For a four-letter, all lowercase password, there are 456,976 different possible permutations of letters. This is because there are 26 possible characters (a-z) and the password is four letters long; 264=456,976. Due to this equation of repetitive permutations, an increased amount of possible characters in the password, as well as the length of the password, greatly increase the amount of possible passwords. Further, if details of a password’s requirements are unknown, such as the length of the password or acceptable characters, the amount of possible passwords is again increased. 
If, for example, both upper and lowercase letters are acceptable password characters, the number of possible passwords increases by a factor of 16, as 524=7,311,616. If all printable English characters are acceptable, there become 94 possible characters, meaning a four-letter password has 78,074,896 possible permutations. Moreover, as mentioned above, the amount of possible password permutations increases if the exact length of a password is unknown. Because approximately 93% of the billions of publicly-available leaked passwords since 2011 are less than 13 and more than 5 characters long, a majority of passwords can be cracked when assumed to be within this range. Using these heuristics, this means that roughly 93% of all user-selected passwords fall within a list of 946 and 9412 permutations; i.e., are one of over 481 sextillion different passwords, as:
 946+947+948+949+9410+9411+9412=481,037,737,554,184,166,869,696
Upon assessment, this dehashing program can calculate and process roughly 15,000 possible plaintext passwords in 1 nanosecond (0.000000001seconds), or fifteen trillion (15,000,000,000,000) passwords per second. Inferring that 93% of all passwords are contained within the 481 sextillion-password-long list of {aaaaaa - zzzzzzzzzzzz, including symbols}, this program can process nearly 93% of all user-selected passwords in 32,069,182,503 seconds, or 1017 years (481 sextillion/15 trillion=32 billion). Clearly, this is an extremely long length of time. However, considering that 79% of all passwords within this range consisted only of lowercase letters, this means that approximately 73.47% of all passwords consist of 6 to 12 all-lowercase letters (.79*.93=.7347). From this, it can be extrapolated that roughly 73.47% of all passwords are contained within a list of 99 quadrillion passwords, as:
266+267+268+269+2610+2611+2612=99,246,114,915,792,832
While the amount of possible password permutations is still seemingly quite high, the amount of time needed to calculate these all-lowercase passwords is reduced astoundingly by over 484 million percent to a mere 1.84 hours:
(8908106-1.84)/1.84*100=484721463
99,246,114,915,792,832/15000000000000=6,616 &  6,616/602=1.837778
This means that roughly 73.5% of all user-selected passwords can be calculated in less than two hours. Further, this time can be improved by utilizing more robust hardware than was used in these tests.
These calculations demonstrate that even if passwords have been hashed, which is widely thought to be irreversible, the original plaintext of those passwords can, in fact, be recovered. Moreover, it is usually thought that the complexity of hashed passwords is inconsequential, but clearly this is not the case. 

Appendix
 ASCII Table:
Below is a table of lowercase letters and their respective ASCII values.



References
"ASCII Table and Description." Ascii Table. N.p., n.d.
"Breaking a Toy Hash Function." Micks Mix. N.p., 02 July 2013.
Chapter 6. Place of Publication Not Identified: Stationery Office, 2006. Web.
"Codelord.net." Statistics of 62K Passwords -. N.p., n.d.
"Combinations and Permutations." Combinations and Permutations. N.p., n.d.
"Cryptographic Hash Functions" Wikimedia Foundation, n.d.
Curley, Robert. Cryptography: Cracking Codes. N.p.: n.p., n.d. Print.
"The Definitive Guide to Cryptographic Hash Functions (Part 1)." Varonis Blog RSS. N.p., 02 Aug. 2012.
"Euclidean Algorithm." Wolfram MathWorld. N.p., n.d.
"Euclidian Division" Wikimedia Foundation, n.d.
"Hash Function." -- from Wolfram MathWorld. N.p., n.d.
"Hash Functions." Hash Functions. N.p., n.d.
"Hash Table Primes." N.p., n.d.
"How Are Passwords Stored on Websites?" Website Research and Interviews. N.p., n.d.
"How Do Modern Websites Check User Passwords without Storing the Clear-text Password in the Database?" - Quora. N.p., n.d.
Kippenhahn, Rudolf, and Manfred Eyssell. Code Breaking: A History and Exploration. New York: Overlook Duckworth, 2012. Print.
"Mike Frank on Reversible Computing." Machine Intelligence Research Institute. Machine Intelligence Research Institute, 31 Jan. 2014.
"Modular Arithmetic." Wikipedia. Wikimedia Foundation, n.d.
"Modulus Operations." Wikipedia. Wikimedia Foundation, n.d.
"Nummerical Hash Function." Khan Academy. N.p., n.d.
Perlroth, Nicole, and David Gelles. "Russian Hackers Amass Over a Billion Internet Passwords." The New York Times. The New York Times, 05 Aug. 2014.
"Prime Number Utilization in Hash Functions." Language Agnostic. N.p., n.d.
"Rafekettler.com." Rafekettler.com. N.p., n.d.
"SHA-1 Hash Function - Secure Cryptographic Hash Function!!!" Khan Academy. N.p., n.d.
"Serious Security: How to Store Your Users’ Passwords Safely." Naked Security. N.p., 20 Nov. 2013.
"Stolen Password? How to Avoid Corporate Password Theft." Security Intelligence. N.p., 13 Aug. 2014.
"The Bitmill Inc." Password Encryption and Storage. N.p., n.d.
"Twisted Oak Studios." Breaking a Toy Hash Function. N.p., n.d.
"Update: LinkedIn Confirms Account Passwords Hacked." PCWorld. N.p., n.d.
"Why Do Hash Functions Use Prime Numbers?" Computing Life. N.p., 20 Nov. 2008.
"What Is Hashing?" SearchSQLServer. N.p., n.d.

Source Code
https://github.com/sinclairb/rppfsuhf

